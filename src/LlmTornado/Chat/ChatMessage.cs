using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using LlmTornado.ChatFunctions;
using LlmTornado.Code;
using LlmTornado.Responses;
using Newtonsoft.Json;

namespace LlmTornado.Chat;

/// <summary>
///     Chat message sent or received from the API. Includes who is speaking in the "role" and the message text in the
///     "content".
/// </summary>
public class ChatMessage
{
	/// <summary>
	///     Creates an empty <see cref="ChatMessage" />, with <see cref="Role" /> defaulting to
	///     <see cref="ChatMessageRoles.User" />
	/// </summary>
	public ChatMessage()
    {
        Role = ChatMessageRoles.User;
        Id = Guid.NewGuid();
    }
	
	/// <summary>
	///     Constructor for a new Chat Message.
	/// </summary>
	/// <param name="role">The role of the message, which can be "system", "assistant, "user", or "function".</param>
	public ChatMessage(ChatMessageRoles role)
	{
		Role = role;
		Id = Guid.NewGuid();
	}

	/// <summary>
	///     Constructor for a new Chat Message.
	/// </summary>
	/// <param name="role">The role of the message, which can be "system", "assistant, "user", or "function".</param>
	/// <param name="content">The text to send in the message</param>
	public ChatMessage(ChatMessageRoles role, string content)
    {
        Role = role;
        Content = content;
        Id = Guid.NewGuid();
    }

	/// <summary>
	///     Constructor for a new Chat Message with multiple parts.
	/// </summary>
	/// <param name="role">The role of the message, which can be "system", "assistant, "user", or "function".</param>
	/// <param name="parts">Parts the message consists of</param>
	public ChatMessage(ChatMessageRoles role, IEnumerable<ChatMessagePart> parts)
    {
        Role = role;
        Parts = parts.ToList();
        Id = Guid.NewGuid();
    }

	/// <summary>
	///     Constructor for a new Chat Message with multiple parts.
	/// </summary>
	/// <param name="role">The role of the message, which can be "system", "assistant, "user", or "function".</param>
	/// <param name="parts">Parts the message consists of</param>
	/// <param name="id">Unique guid acting as an identifier. If null, assigned automatically.</param>
	public ChatMessage(ChatMessageRoles role, IEnumerable<ChatMessagePart> parts, Guid? id)
    {
        Role = role;
        Parts = parts.ToList();
        Id = id ?? Guid.NewGuid();
    }

	/// <summary>
	///     Constructor for a new Chat Message.
	/// </summary>
	/// <param name="role">The role of the message, which can be "system", "assistant, "user", or "function".</param>
	/// <param name="content">The text to send in the message</param>
	/// <param name="id">Unique guid acting as an identifier. If null, assigned automatically.</param>
	public ChatMessage(ChatMessageRoles role, string content, Guid? id)
    {
        Role = role;
        Content = content;
        Id = id ?? Guid.NewGuid();
    }

    /// <summary>
    ///     The role of the message, which can be "system", "assistant", "user" or "function".
    ///		Reasoning models from OpenAI also use "developer" role, which is aliased into "system" in Tornado.
    /// </summary>
    [JsonIgnore]
    public ChatMessageRoles? Role { get; set; }
    
    /// <summary>
    ///		The amount of tokens used for this message.
    /// </summary>
    [JsonIgnore]
    public int? Tokens { get; set; }

    /// <summary>
    ///     The content of the message.
    /// </summary>
    [JsonProperty("content")]
    public string? Content { get; set; }

    /// <summary>
    ///		Reasoning, if any. Most providers report this as a rich block, Tornado uses this property only for reading.
    /// </summary>
    [JsonProperty("reasoning")]
    public string? Reasoning { get; set; }
    
    /// <summary>
    ///     The reason why model refused to respond.
    /// </summary>
    [JsonProperty("refusal")]
    public string? Refusal { get; set; }
    
    /// <summary>
    ///     Audio block content.
    /// </summary>
    [JsonProperty("audio")]
    public ChatMessageAudio? Audio { get; set; }
    
    /// <summary>
    ///     The parts of the message. When serializing, <see cref="Parts"/> have priority over <see cref="Content"/>
    /// </summary>
    [JsonIgnore]
    public List<ChatMessagePart>? Parts { get; set; }

    /// <summary>
    ///     An optional name of the user in a multi-user chat.
    /// </summary>
    [JsonProperty("name")]
    public string? Name { get; set; }

    /// <summary>
    ///     Assigned in ctor. Use to remove / update messages from conversation.
    /// </summary>
    [JsonIgnore]
    public Guid Id { get; internal set; }

    /// <summary>
    ///		Reasoning content, currently used only by Grok 3.
    /// </summary>
    [JsonProperty("reasoning_content")]
    public string? ReasoningContent { get; set; }
    
    /// <summary>
    ///     Optional field tool calls
    ///     The name and arguments of tools that should be called, as generated by the model.
    /// </summary>
    [JsonProperty("tool_calls")]
    public List<ToolCall>? ToolCalls { get; set; }

    /// <summary>
    ///     Optional field tool call id.
    ///     This is used after an assistant message with tools.
    /// </summary>
    [JsonProperty("tool_call_id")]
    public string? ToolCallId { get; set; }
    
    /// <summary>
    ///     Optional flag indicating whether <see cref="ToolCallId"/> invocation succeeded.
    /// </summary>
    [JsonIgnore]
    public bool? ToolInvocationSucceeded { get; set; }
    
    /// <summary>
    ///		Flags the message as excluded from the final request.
    /// </summary>
    [JsonIgnore]
    internal bool ExcludeFromRequest { get; set; }

    [JsonIgnore] 
    internal Dictionary<string, ToolCallInboundAccumulator>? ToolCallsDict;
    
    [JsonIgnore]
    internal object? ChatMessageSerializeData { get; set; }
    
    [JsonIgnore]
    internal StringBuilder? ContentBuilder { get; set; }
    
    [JsonIgnore]
    internal Type? ContentJsonType { get; set; }
    
    [JsonIgnore]
    internal FunctionCall? FunctionCall { get; set; }
    
    [JsonIgnore]
    internal CustomToolCall? CustomToolCall { get; set; }
    
    [JsonIgnore]
    internal ChatRequest? Request { get; set; }
    
    /// <summary>
    /// Shared "Prefix" field, currently supported by Mistral
    /// </summary>
    internal bool? Prefix { get; set; }
    
    /// <summary>
    ///  Vendor extensions to the message.
    /// </summary>
    [JsonIgnore]
    public IChatMessageVendorExtensions? VendorExtensions { get; set; }
    
    /// <summary>
    /// The native object this chat message was constructed from, if any. Could be <see cref="ResponseResult"/>
    /// </summary>
    [JsonIgnore]
    public object? NativeObject { get; set; }
}

/// <summary>
/// Vendor extensions to chat message.
/// </summary>
public interface IChatMessageVendorExtensions
{
	
}

/// <summary>
/// Anthropic's extensions to chat messages.
/// </summary>
public class ChatMessageVendorExtensionsAnthropic : IChatMessageVendorExtensions
{
	/// <summary>
	/// Signature used for COT integrity verification.
	/// </summary>
	public string? Signature { get; set; }
}


public static class ChatMessageExtensions
{
    /// <summary>
    ///     Gets the text content of a message, combining Content and Parts.
    /// </summary>
    public static string GetMessageContent(this ChatMessage message)
    {
        if (message.Content != null)
        {
            return message.Content;
        }

        if (message.FunctionCall != null)
        {
            return message.FunctionCall.ToJson(true);
        }

        string partsContent = string.Empty;
        if (message.Parts != null)
        {
            partsContent = string.Join(" ", message.Parts.Where(p => p.Text != null).Select(p => p.Text));
            if (message.Parts.Any(p => p.Reasoning is not null))
            {
                partsContent += "\n [REASONING]: " + string.Join(" ", message.Parts.Where(p => !string.IsNullOrEmpty(p.Reasoning?.Content)).Select(p => p.Reasoning?.Content));
            }
        }

        return partsContent;
    }


    /// <summary>
    ///     Gets the approximate character length of a message, including all parts.
    /// </summary>
    public static int GetMessageLength(this ChatMessage message)
    {
        int length = 0;

        if (message.Content != null)
        {
            length += message.Content.Length;
        }

        if (message.Parts != null)
        {
            foreach (ChatMessagePart part in message.Parts)
            {
                if (part.Text != null)
                {
                    length += part.Text.Length;
                }
                // Note: Images, audio, and other non-text parts are being stripped after compression
            }
        }

        if (message.Reasoning != null)
        {
            length += message.Reasoning.Length;
        }

        if (message.ReasoningContent != null)
        {
            length += message.ReasoningContent.Length;
        }

        return length;
    }
}