# Agent As Tool

## Overview

LlmTornado allows you to use one agent as a tool for another agent, enabling hierarchical agent systems where specialist agents can be called by a coordinator agent. This pattern is powerful for building complex multi-agent workflows.

## Quick Start

```csharp
using LlmTornado.Agents;

// Create specialist agent
TornadoAgent weatherAgent = new TornadoAgent(
    client: api,
    model: ChatModel.OpenAi.Gpt41.V41Mini,
    name: "WeatherAgent",
    instructions: "You are a weather specialist. Provide detailed weather information."
);

// Create coordinator agent with specialist as tool
TornadoAgent coordinator = new TornadoAgent(
    client: api,
    model: ChatModel.OpenAi.Gpt41.V41,
    name: "Coordinator",
    instructions: "You coordinate tasks. Use the WeatherAgent for weather queries.",
    tools: new List<Delegate> { weatherAgent.AsTool }
);

// Coordinator calls specialist when needed
Conversation result = await coordinator.RunAsync("Plan my outdoor event considering the weather");
```

## Creating Agent Tools

### Basic Agent Tool

```csharp
// Create specialist agent
TornadoAgent mathAgent = new TornadoAgent(
    api,
    ChatModel.OpenAi.Gpt41.V41Mini,
    name: "MathExpert",
    instructions: "You are a mathematics expert. Solve complex math problems."
);

// Use as tool
TornadoAgent mainAgent = new TornadoAgent(
    api,
    ChatModel.OpenAi.Gpt41.V41,
    tools: new List<Delegate> { mathAgent.AsTool }
);
```

### Multiple Agent Tools

```csharp
// Create multiple specialist agents
TornadoAgent codeAgent = new TornadoAgent(
    api, model,
    name: "CodeExpert",
    instructions: "Expert in code review and programming."
);

TornadoAgent securityAgent = new TornadoAgent(
    api, model,
    name: "SecurityExpert",
    instructions: "Expert in security analysis."
);

TornadoAgent architectAgent = new TornadoAgent(
    api, model,
    name: "ArchitectExpert",
    instructions: "Expert in system architecture."
);

// Coordinator with multiple specialists
TornadoAgent coordinator = new TornadoAgent(
    api, model,
    name: "TechLeadCoordinator",
    instructions: "Coordinate technical tasks across specialists.",
    tools: new List<Delegate> 
    { 
        codeAgent.AsTool,
        securityAgent.AsTool,
        architectAgent.AsTool
    }
);
```

## Use Cases

### Task Decomposition

```csharp
// Research agent
TornadoAgent researcher = new TornadoAgent(
    api, model,
    name: "Researcher",
    instructions: "Research topics and gather information."
);

// Analysis agent
TornadoAgent analyzer = new TornadoAgent(
    api, model,
    name: "Analyzer",
    instructions: "Analyze data and provide insights."
);

// Writing agent
TornadoAgent writer = new TornadoAgent(
    api, model,
    name: "Writer",
    instructions: "Write comprehensive reports."
);

// Coordinator orchestrates workflow
TornadoAgent projectManager = new TornadoAgent(
    api, model,
    name: "ProjectManager",
    instructions: "Manage complex projects using specialist agents.",
    tools: new List<Delegate> 
    { 
        researcher.AsTool,
        analyzer.AsTool,
        writer.AsTool
    }
);

Conversation result = await projectManager.RunAsync(
    "Create a comprehensive market analysis report for electric vehicles"
);
```

### Domain Specialization

```csharp
// Legal specialist
TornadoAgent legalAgent = new TornadoAgent(
    api, model,
    name: "LegalAdvisor",
    instructions: "Provide legal advice and review contracts.",
    outputSchema: typeof(LegalReview)
);

// Financial specialist  
TornadoAgent financeAgent = new TornadoAgent(
    api, model,
    name: "FinancialAdvisor",
    instructions: "Provide financial analysis and advice.",
    outputSchema: typeof(FinancialAnalysis)
);

// Business coordinator
TornadoAgent businessAgent = new TornadoAgent(
    api, model,
    name: "BusinessAdvisor",
    instructions: "Provide comprehensive business advice using specialists.",
    tools: new List<Delegate> { legalAgent.AsTool, financeAgent.AsTool }
);
```

## Best Practices

### Agent Hierarchy Design
- Keep hierarchies shallow (2-3 levels max)
- Define clear responsibilities for each agent
- Avoid circular dependencies
- Use descriptive names for agents

### Communication
- Provide clear instructions about when to use each agent
- Define input/output formats between agents
- Handle errors at each level
- Log agent interactions for debugging

### Performance
- Be aware of token costs (each agent call uses tokens)
- Consider caching for frequently used specialist results
- Monitor execution times
- Limit recursion depth

## Advanced Usage

### Dynamic Agent Tool Registration

```csharp
TornadoAgent coordinator = new TornadoAgent(api, model);

// Add agent tools dynamically
TornadoAgentTool agentTool = new TornadoAgentTool(specialistAgent);
coordinator.AddAgentTool(agentTool);
```

### Conditional Agent Use

```csharp
string instructions = @"
You are a task coordinator. Use these rules:
- Use CodeExpert for programming questions
- Use SecurityExpert for security concerns
- Use ArchitectExpert for system design
- Handle simple queries yourself
";

TornadoAgent coordinator = new TornadoAgent(
    api, model,
    instructions: instructions,
    tools: specialistTools
);
```

## Common Issues

### Infinite Loops
**Solutions**:
- Avoid agent A calling agent B which calls agent A
- Implement depth limits
- Monitor call chains
- Add termination conditions

### High Token Usage
**Solutions**:
- Limit conversation history passed to specialists
- Use simpler models for specialist agents
- Cache specialist responses when appropriate
- Trim unnecessary context

### Poor Coordination
**Solutions**:
- Improve coordinator instructions
- Make specialist roles more distinct
- Provide examples of when to use each specialist
- Test with various scenarios

## Related Topics

- [Agent Basics](../1.%20basics.md)
- [Function Tools](./1.%20Function-Tools.md)
- [Agent Orchestration](../../3.%20Agent-Orchestration/1.%20basics.md)
