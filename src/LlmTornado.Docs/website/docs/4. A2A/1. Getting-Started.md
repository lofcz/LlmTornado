# A2A (Agent-to-Agent) - Getting Started

## Overview

LlmTornado A2A provides a framework for building distributed agent systems where multiple agents can communicate and collaborate across network boundaries. The A2A architecture enables scalable, modular agent systems with standardized communication protocols.

## Introduction

Agent-to-Agent (A2A) communication enables:
- **Distributed Agent Systems**: Deploy agents across multiple servers
- **Modular Architecture**: Independent agent services that can be composed
- **Scalability**: Scale individual agent services independently
- **Interoperability**: Standardized communication between different agent types
- **Isolation**: Agents run in isolated environments (containers)

## Installation

Download the template to create A2A LlmTornado Agents!:

```bash
From the Github Templates Folder download the Template Zip for A2A.AgentServer

```

## Architecture Overview

The A2A system consists of four main components:

### 1. Agent Runtime Configuration
Provides the necessary configuration and context for agents to operate within their environment. Defines how agents behave and interact.

```csharp
public class MyA2ARuntime : BaseA2ATornadoRuntimeConfiguration
{
    public override AgentCard DescribeAgentCard(string agentUrl)
    {
        return new AgentCard
        {
            Name = "MyAgent",
            Description = "A specialized agent for specific tasks",
            Url = agentUrl,
            Capabilities = new[] { "task1", "task2" }
        };
    }
}
```

### 2. A2A Agent Server
Main A2A API that runs the Agent Runtime and manages agent interactions. This is where agents are built and executed.

- Hosts individual agents as services
- Exposes agents via REST API
- Handles incoming requests and routes to agents
- Manages agent lifecycle

### 3. A2A Agent Hosting [Experimental]
Custom API which launches dockerized A2A Agent Servers and manages their lifecycle and communication.

- Orchestrates multiple agent servers
- Manages Docker containers for each agent
- Routes requests between agents
- Monitors agent health

### 4. A2A Web UI [Experimental]
Provides a user interface for launching, interacting with, and monitoring A2A agents and their activities.

- Visual interface for agent management
- Real-time monitoring
- Agent configuration
- Testing and debugging tools

## Quick Start

### Creating Your First A2A Agent

```csharp
using LlmTornado.A2A;
using LlmTornado.Agents;

// 1. Define your runtime configuration
public class WeatherAgentRuntime : BaseA2ATornadoRuntimeConfiguration
{
    public override AgentCard DescribeAgentCard(string agentUrl)
    {
        return new AgentCard
        {
            Name = "WeatherAgent",
            Description = "Provides weather information",
            Url = agentUrl,
            Version = "1.0.0",
            Capabilities = new[] { "weather", "forecast" }
        };
    }
    
    protected override TornadoAgent CreateAgent()
    {
        return new TornadoAgent(
            client: api,
            model: ChatModel.OpenAi.Gpt41.V41Mini,
            instructions: "You are a weather information specialist.",
            tools: new List<Delegate> { GetWeather, GetForecast }
        );
    }
}

// 2. Create agent server (Program.cs)
WebApplicationBuilder builder = WebApplication.CreateBuilder(args);
builder.Services.AddA2AAgentServer<WeatherAgentRuntime>();

WebApplication app = builder.Build();
app.MapA2AAgentEndpoints();
app.Run();
```

### Creating A2A Agents

#### BaseA2ATornadoRuntimeConfiguration

When creating a new A2A Runtime configuration, inherit from `BaseA2ATornadoRuntimeConfiguration` and implement the abstract method `DescribeAgentCard(string agentUrl)`:

```csharp
public class TaskAgentRuntime : BaseA2ATornadoRuntimeConfiguration
{
    public override AgentCard DescribeAgentCard(string agentUrl)
    {
        return new AgentCard
        {
            Name = "TaskAgent",
            Description = "Manages and executes tasks",
            Url = agentUrl,
            Version = "1.0.0",
            Capabilities = new[] 
            { 
                "create_task",
                "update_task",
                "delete_task",
                "list_tasks"
            },
            Tags = new[] { "productivity", "management" }
        };
    }
    
    protected override TornadoAgent CreateAgent()
    {
        // Define tools
        string CreateTask(string title, string description)
        {
            return $"Task created: {title}";
        }
        
        string ListTasks()
        {
            return "Current tasks: ...";
        }
        
        return new TornadoAgent(
            client: api,
            model: ChatModel.OpenAi.Gpt41.V41,
            instructions: "You are a task management specialist.",
            tools: new List<Delegate> { CreateTask, ListTasks }
        );
    }
}
```

## Communication Protocol

A2A agents communicate using a standardized protocol:

```csharp
// Request format
public class A2ARequest
{
    public string AgentId { get; set; }
    public string Message { get; set; }
    public Dictionary<string, object>? Context { get; set; }
}

// Response format
public class A2AResponse
{
    public string AgentId { get; set; }
    public string Response { get; set; }
    public Dictionary<string, object>? Metadata { get; set; }
}
```

## Customizing the Pipeline

You can implement `IA2ARuntimeConfiguration` to create your own custom runtime configuration rules:

```csharp
public interface IA2ARuntimeConfiguration
{
    AgentCard DescribeAgentCard(string agentUrl);
    Task<A2AResponse> HandleRequest(A2ARequest request);
    Task InitializeAsync();
}

public class CustomA2ARuntime : IA2ARuntimeConfiguration
{
    public AgentCard DescribeAgentCard(string agentUrl)
    {
        // Custom card generation
    }
    
    public async Task<A2AResponse> HandleRequest(A2ARequest request)
    {
        // Custom request handling
    }
    
    public async Task InitializeAsync()
    {
        // Custom initialization
    }
}
```

## Deployment

### Docker Deployment

Each agent runs in its own Docker container:

```dockerfile
# Dockerfile
FROM mcr.microsoft.com/dotnet/aspnet:8.0
WORKDIR /app
COPY . .
ENTRYPOINT ["dotnet", "MyAgent.dll"]
```

```bash
# Build image
docker build -t my-weather-agent .

# Run with API key
docker run -p 5000:80 \
  -e OPENAI_API_KEY=your_api_key \
  my-weather-agent
```

### Docker Compose

Orchestrate multiple agents:

```yaml
version: '3.8'
services:
  weather-agent:
    image: weather-agent:latest
    ports:
      - "5001:80"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
      
  task-agent:
    image: task-agent:latest
    ports:
      - "5002:80"
    environment:
      - OPENAI_API_KEY=${OPENAI_API_KEY}
```

## Best Practices

### Agent Design
- Keep agents focused on specific domains
- Define clear capabilities in agent cards
- Implement proper error handling
- Use versioning for breaking changes

### Communication
- Use standardized message formats
- Include context when needed
- Handle timeouts gracefully
- Implement retry logic

### Security
- Validate all incoming requests
- Use authentication/authorization
- Sanitize inputs and outputs
- Encrypt sensitive data

### Monitoring
- Log all agent interactions
- Track performance metrics
- Monitor agent health
- Implement alerting

## Next Steps

Explore the detailed documentation for each component:
- [Agent Server](./2.%20Agent-Server.md) - Building and deploying agent servers
- [Hosting Server](./3.%20Hosting-Server.md) - Orchestrating multiple agents
- [Web UI](./4.%20Web-UI.md) - Managing agents through the web interface

## Related Topics

- [Agent Basics](../2.%20Agents/1.%20Getting-Started.md)
- [Agent Orchestration](../2.%20Agents/3.%20Agent-Orchestration/1.%20basics.md)
- [Chat Runtime](../2.%20Agents/4.%20Chat-Runtime.md)
